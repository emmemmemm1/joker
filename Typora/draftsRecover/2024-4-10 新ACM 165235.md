此板子只有部分内容，原因是“ACM”中图片使用的是绝对路径无法正常转移使用

---

## 后缀数组（SA）    

- 学习掌握 SA
- 解决 LCP 问题（最长公共前缀）

约定 ： 字符串下标从 `1`开始，长度为`n`，“`后缀 i`”代指以第 `i`个字符开头的后缀，存储时用`i`代表字符串 s 的后缀 `s[i...n]`。

- 需要的数组介绍

```cpp
sa[i]//表示将所有后缀排序后第 i 小的后缀的编号，也就是后缀数组，编号数组
rk[i]//表示后缀 i 的排名，是重要的辅助数组，后文也称排名数组 rk
```
- 性质 ：

`sa[rk[i]] = rk[sa[i]] = i`
![后缀数组解释](.\images\后缀数组解释.png)

### 求后缀数组

#### 暴力做法    $O(n^2logn)$

直接暴力`sort`的做法，枚举每一种后缀数组。

#### 倍增做法     $O(nlog^2n)$

首先对字符串`s`的所有长度为 1 的子串进行排序，得到排序后的编号数组$sa_1 和排名数组 rk_1$。用两个连接起来的长度为 1 的子串作为排序的两个关键字(靠前的子串为第一关键字)进行排序，得到长度为 2 的子串排序结果，类推。**注意**：当`i + l > n`的时候将$s_{i+w}$视作无限小，当倍增的长度大于等于`n`的时候即可得到后缀数组`sa`。

![](.\images\后缀数组倍.png)

```cpp
int sa[N],rk[N],oldrk[N];
inline bool cmp(int x,int y,int w)//第x，y个后缀数组，w表示拼接长度
{
    return (rk[x] != rk[y] ? (rk[x + w] < rk[y + w]) : (rk[x] < rk[y]));
}
```







