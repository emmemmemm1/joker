此板子只有部分内容，原因是“ACM”中图片使用的是绝对路径无法正常转移使用

---

## 后缀数组（SA）    

- 学习掌握 SA
- 解决 LCP 问题（最长公共前缀）

约定 ： 字符串下标从 `1`开始，长度为`n`，“`后缀 i`”代指以第 `i`个字符开头的后缀，存储时用`i`代表字符串 s 的后缀 `s[i...n]`。

- 需要的数组介绍

```cpp
sa[i]//表示将所有后缀排序后第 i 小的后缀的编号，也就是后缀数组，编号数组
rk[i]//表示后缀 i 的排名，是重要的辅助数组，后文也称排名数组 rk
```
- 性质 ：

`sa[rk[i]] = rk[sa[i]] = i`
![后缀数组解释](.\images\后缀数组解释.png)

### 求后缀数组

#### 暴力做法    $O(n^2logn)$

直接暴力`sort`的做法，枚举每一种后缀数组。

#### 倍增做法     $O(nlog^2n)$

首先对字符串`s`的所有长度为 1 的子串进行排序，得到排序后的编号数组$sa_1 和排名数组 rk_1$。

倍增过程

​	1.用两个长度为 1 的子串的排名，即 $rk_1[i] 和 rk_1[i + 1] $ ，作为排序的第一第二关键字，就可以对字符串 ![s](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 的每个长度为 2 的子串：{s[i...min(i + 1,n)] | $i\in[1,n] $}![\{s[i\dots \min(i+1, n)]\ |\ i \in [1,\ n]\}](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 进行排序，得到 $sa_2 和 rk_2$；

​	2.用两个长度为 `w` 的子串的排名，即 $rk_1[i] 和 rk_1[i + w / 2] $ ，作为排序的第一第二关键字，就可以对字符串 ![s](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 的每个长度为`w`的子串：{s[i...min(i + w - 1,n)] | $i\in[1,n] $}![\{s[i\dots \min(i+1, n)]\ |\ i \in [1,\ n]\}](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 进行排序，得到 $sa_w 和 rk_w$；其中地方那个

![倍增做法](.\Images/后缀数组倍增算法.png)

```cpp
int sa[N],rk[N],oldrk[N];
inline bool cmp(int x,int y,int w)//第x，y个后缀数组，w表示拼接长度
{
    return (rk[x] != rk[y] ? (rk[x + w] < rk[y + w]) : (rk[x] < rk[y]));
}
```







