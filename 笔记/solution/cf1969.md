## C   --- DP   

---

[Educational Codeforces Round 165 (Rated for Div. 2) (C、D）-CSDN博客](https://blog.csdn.net/weixin_61825750/article/details/138330161)

观察数据 k 非常小，`dp[i][j]`表示前 `i` 个数，操作了`j`次可以取得的最小值，枚举 i ，枚举最大可以从前面转移过来的下标（即是当前 i 最多可以转移次数），枚举连续使用转移次数

```cpp
for(int i=1;i<=n;i++)
{
    for(int j=0;j<=min(i-1,k);j++)
    {
        for(int c=0;c<=j;c++)
        {
            int mi = a[i];
            for(int p=i;p>=i-c;p--)
                mi = min(mi,a[p]);
           	dp[i][j] = min(dp[i][j],dp[i - c - 1][j - c] + mi * (c + 1));
        }//i - c - 1表示 i - c 是可以操作的，由上一个转移，c + 1 是指包含 i 这一位
    }
}
ans = min{a[n][x]};
```





## D   --- 优先队列，模拟，数学

---

本题主要考虑是否舍弃一部分，使得答案更优，最优解 B 一定会拿 b 较大的，这样才会使得最小化利润，但是 A 可以不选这种数据，选择 a 和 b 差距较大的部分，使得利润更大，要知道，之前未被选择免费拿走的部分后面一定不会免费拿走，免费拿走一定是当前保留的部分中 b 最大的 k 个，这样才会 B 最优，两个堆，一个表示已经免费拿走的对应的 a，用于计算舍弃这些数据之后利润重新加上这些，表示未买这种，然后减去 b ，表示免费拿走，B  不需要花费钱

**注意：** 排序的时候不能只按照 b 大的顺序来排序，需要注意到在 b 一样大的时候还需要按照 a 小的顺序，这样才会使得免费拿走同等价值的 b 时，A支付的最少，即是 A 最优