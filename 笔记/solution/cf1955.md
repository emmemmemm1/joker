[Codeforces Round 938 (Div. 3) A-H 题解 - Martian148 - 博客园 (cnblogs.com)](https://www.cnblogs.com/martian148/p/18127361)

## **E**          

这次相对来说 n 的数据范围较小，找到最大的满足条件的答案，我们可以直接暴力处理，ans从大到小枚举，从前往后枚举区间，如果当前数据是`0`我们必须要进行操作，将`[i,i + ans - 1]`这一段的数据翻转，如果我们暴力显然肯定`TLE`，所以使用树状数组，每次 `now ^= （query(i)&1）`，我们知道偶数次操作是无效的，此时`^`操作一下我们既可以判断操作之后当前状态是`0 或 1`,是 0 额外操作一次，1 跳过，最后判断数组后面剩余的是否全是 1 即可



## F

本题考虑二进制，二进制状态下 4 是单独的，异或为 0 的话只能自己的个数是偶数，所以对答案的贡献是 cnt[4] / 2，对于1，2，3只有当三个数个数都是奇数的时候贡献才是 `cnt[1] / 2 + cnt[2] / 2 + cnt[3] / 2 + 1`,其余情况都是`cnt[1] / 2 + cnt[2] / 2 + cnt[3] / 2`。





## G

分析可知，最终的结果一定是`__gcd(a[1][1],a[1][m])`的所有因子中最大满足条件的那个因子，只有这样才能保证可以出发结束，注意到`n * m`还是比较大的，不能直接 `bfs`我们只需要从左、上两个点来判断当前点是否可达，没必要`bfs`持续跑。假设这个点能到，则判断这个点是否可整除`ans`，可以更新右，下两个位置，不可以更新自己为0(后面的点不可以通过这个点到达)。

---

TLE  到死，数组还是开全局，局部很慢，相差  5 倍以上，开在全局，使用前清零即可！！！！！！！！！
